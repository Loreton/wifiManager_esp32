--- CONTESTO PROGETTO ESP32 ---


--- FILE: ./platformio.ini ---
;PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html

; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html



; [env:esp32_littleFS]
[env:esp32]
    # # sembra funzionare con AzDelivery ESP32-WROOM 32
    ; platform = espressif32@^6.8.0   #; 6.0.0. or the latest stable version (per ledcSetup())
    platform = espressif32
    framework = arduino
    board = esp32dev
    upload_speed = 460800
    monitor_speed = 115200
    monitor_filters = colorize
    upload_port = /dev/ttyUSB0
    # board_build.filesystem = littlefs
    # extra_scripts = presscontrol_extra_flags.py



    # -------------------------------------
    # ref: https://docs.platformio.org/en/stable/search.html?q=lib_deps&check_keywords=yes&area=default
    #   per le mie librerie posso ettere il path di github:
    #       https://github.com/Loreton/wifiManager.git
    # -------------------------------------
    lib_deps =
        ; paulstoffregen/OneWire @ ^2.3.8
        ; milesburton/DallasTemperature @ ^4.0.6
        ; Aircoookie/Espalexa @ ^2.7.0
        ; witnessmenow/UniversalTelegramBot @ ^1.3.0
        fbiego/ESP32Time @ ^2.0.6
        ; https://github.com/Loreton/wifiManager.git
        ; cotestatnt/AsyncTelegram2 @ ^2.1.8


    # -------------------------------------
    # ref: https://docs.platformio.org/en/stable/projectconf/sections/env/options/build/build_flags.html
    # -------------------------------------
    build_flags=
        # -D LOG_LEVEL=${sysenv.LOG_LEVEL}
        ${sysenv.ADDITIONAL_BUILD_FLAGS}
        ; -I ./include
        -I /home/loreto/filu/lnEnv/config/envars/include # per ssid.h e telegram_bot.h  @ln_ssid_credentials.h
        ; -D __ln_MODULE_DEBUG_TEST__



    ; ref: https://docs.platformio.org/en/stable/projectconf/sections/env/options/library/lib_ignore.html
    lib_ignore =
        @testArea # solo nome del folder senza il path
        examples # solo nome del folder senza il path
        samples # solo nome del folder senza il path


    # -------------------------------------
    # inserire le librerie esterne o personali da includere nella compilazione
    # considerare che pr i relative path, la base_dir --> same level of src
    # -------------------------------------
    lib_extra_dirs =
        ; ../lnEsp32Libraries


    # -------------------------------------
    # ref: https://docs.platformio.org/en/stable/projectconf/sections/env/options/build/build_src_filter.html
    # inserire tutti i percorsi che si desidera inserire nel codice
    # considerare che per i relative path, la base_dir --> src
    # -------------------------------------
    build_src_filter =
        ; +<./test>







[platformio]
    ; src_dir = .
    # ref: https://docs.platformio.org/en/latest/projectconf/sections/platformio/options/directory/lib_dir.html
    # default_envs = nodemcu32
    default_envs = esp32
    # default_envs = esp32




--- FILE: ./src/WiFiManager.h ---
//
// updated by ...: Loreto Notarantonio
// Date .........: 13-09-2025 17.32.34
//


#pragma once

#include <Arduino.h>
#include <WiFi.h>
#include <vector>

class WiFiManagerNB {
    public:
        WiFiManagerNB();

        void init(uint32_t scanIntervalWhenConnected,
                  uint32_t scanIntervalWhenNotConnected,
                  uint32_t maxWifiTimeout,
                  int rssiGap);

        void update();
        void addSSID(const char* ssid, const char* password);

        bool isConnected();
        String getConnectedSSID();

    private:
        static WiFiManagerNB* s_instance;
        static void WiFiEventHandler(WiFiEvent_t event, WiFiEventInfo_t info);

        struct WifiCredential {
            String ssid;
            String password;
        };

        std::vector<WifiCredential> m_credentials;

        uint32_t m_scanIntervalWhenConnected;
        uint32_t m_scanIntervalWhenNotConnected;
        uint32_t m_maxWifiTimeout;

        uint32_t m_lastScanTime = 0;
        uint32_t m_lastConnectedTime = 0;

        int m_rssiGap;
        String m_currentSSID;

        void startScan();
        void handleScanResult();
        void connectToBestNetwork();
        void onWiFiEvent(WiFiEvent_t event);
};



--- FILE: ./src/WiFiManager.cpp ---
//
// updated by ...: Loreto Notarantonio
// Date .........: 20-02-2026 17.16.03
//


// #include "lnLogger_Class.h"

#include "WiFiManager.h"

WiFiManagerNB::WiFiManagerNB() {}
WiFiManagerNB* WiFiManagerNB::s_instance = nullptr;

void WiFiManagerNB::init(uint32_t scanIntervalWhenConnected, uint32_t scanIntervalWhenNotConnected, uint32_t maxWifiTimeout, int rssiGap) {
    m_scanIntervalWhenConnected = scanIntervalWhenConnected;
    m_scanIntervalWhenNotConnected = scanIntervalWhenNotConnected;
    m_maxWifiTimeout = maxWifiTimeout;
    m_rssiGap = rssiGap;

    WiFi.mode(WIFI_STA);
    WiFi.disconnect(true);

    s_instance = this;
    WiFi.onEvent(WiFiEventHandler);

    startScan();
}


void WiFiManagerNB::WiFiEventHandler(WiFiEvent_t event, WiFiEventInfo_t info) {
    if (s_instance) {
        s_instance->onWiFiEvent(event);
    }
}





// =======================================================
//  wifiManager.addSSID("Casetta", "PASSWORD1");
//  wifiManager.addSSID("SSID2", "PASSWORD2");
//  wifiManager.addSSID("SSID3", "PASSWORD3");
// =======================================================
void WiFiManagerNB::addSSID(const char* ssid, const char* password) {
    Serial.println(ssid);
    WifiCredential cred;
    cred.ssid = ssid;
    cred.password = password;
    m_credentials.push_back(cred);
}

void WiFiManagerNB::update() {
    uint32_t now = millis();

    bool connected = (WiFi.status() == WL_CONNECTED);

    if (connected) {
        m_lastConnectedTime = now;
    }
    else {
        if (now - m_lastConnectedTime > m_maxWifiTimeout) {
            Serial.println("Max WiFi timeout reached. Restarting scan.");
            startScan();
            m_lastConnectedTime = now;
        }
    }

    uint32_t interval = connected ? m_scanIntervalWhenConnected : m_scanIntervalWhenNotConnected;
    if (now - m_lastScanTime >= interval) {
        m_lastScanTime = now; moved down
        startScan();
    }

    int scanStatus = WiFi.scanComplete();
    if (scanStatus >= 0) {
        handleScanResult();
        WiFi.scanDelete();
        // m_lastScanTime = now; // spostato come suggerito
    }
}

void WiFiManagerNB::startScan() {
    if (WiFi.scanComplete() == -2) {// no scan running
        Serial.println("Starting scan....");
        WiFi.scanNetworks(true); // async
    }
}

void WiFiManagerNB::handleScanResult() {
    int n = WiFi.scanComplete();
    if (n <= 0)
        return;

    int bestRSSI = -1000;
    String bestSSID = "";
    String bestPassword = "";

    for (int i = 0; i < n; ++i) {
        String ssid = WiFi.SSID(i);
        int rssi = WiFi.RSSI(i);
        Serial.print("SSID: ");Serial.print(ssid);Serial.print(" - RSSI: ");Serial.println(rssi);

        for (auto &cred : m_credentials) {
            if (ssid == cred.ssid) {
                if (rssi > bestRSSI) {
                    bestRSSI = rssi;
                    bestSSID = cred.ssid;
                    bestPassword = cred.password;
                }
            }
        }
    }

    if (bestSSID == "") {
        Serial.print("no better SSID found. standing on: ");Serial.println(WiFi.SSID());
        return;
    }

    if (WiFi.status() == WL_CONNECTED) {
        int currentRSSI = WiFi.RSSI();
        if (bestSSID == m_currentSSID) {
            Serial.print("best ssid is already active: ");Serial.println(WiFi.SSID());
            return;
        }

        if ((bestRSSI - currentRSSI) < m_rssiGap) {
            Serial.print("gap between current ssid and best ssid is:");Serial.println(bestRSSI - currentRSSI);
            return;
        }

        Serial.println("Switching to stronger SSID: " + bestSSID);
        WiFi.disconnect();
    }

    m_currentSSID = bestSSID;
    WiFi.begin(bestSSID.c_str(), bestPassword.c_str());
}

void WiFiManagerNB::onWiFiEvent(WiFiEvent_t event) {
    switch (event) {
        case ARDUINO_EVENT_WIFI_STA_CONNECTED:
            Serial.println("WiFi Connected");
            break;

        case ARDUINO_EVENT_WIFI_STA_GOT_IP:
            Serial.println("Got IP: " + WiFi.localIP().toString());
            break;

        case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:
            Serial.println("WiFi Disconnected");
            break;

        default:
            break;
    }
}

bool WiFiManagerNB::isConnected() {
    return WiFi.status() == WL_CONNECTED;
}

String WiFiManagerNB::getConnectedSSID() {
    return m_currentSSID;
}


USER QUESTION: E' possibile modificare gli oggetti String in char * ed effettuare le modifiche che ritieni critiche nel codice ritornami il codice modificato?


==================== RISPOSTA ====================
Il codice che hai presentato è una buona base per un **WiFi Manager non-blocking** su ESP32, capace di gestire più credenziali e di fare "roaming" (passare alla rete più forte).

Ecco un'analisi dettagliata suddivisa per punti di forza, potenziali bug e suggerimenti di miglioramento.

### 1. Punti di Forza (Pro)
*   **Non-blocking**: L'uso di `WiFi.scanNetworks(true)` (asincrono) è eccellente perché non blocca l'esecuzione del resto del programma (il loop principale).
*   **Gestione Eventi**: L'uso di `WiFi.onEvent` è il modo corretto di gestire lo stato della connessione su ESP32, rendendo il codice più reattivo.
*   **Logica di Roaming**: L'introduzione di `m_rssiGap` è fondamentale per evitare l'"effetto rimbalzo" (ping-pong) tra due reti con segnale simile.
*   **Flessibilità**: Permette di aggiungere più SSID, utile per dispositivi che si spostano tra casa, ufficio o hotspot mobile.

---

### 2. Criticità e Potenziali Bug

#### A. Il problema del "Same SSID" (Roaming AP-to-AP)
Nel metodo `handleScanResult`:
```cpp
if (bestSSID == m_currentSSID) {
    Serial.print("best ssid is already active: ");Serial.println(WiFi.SSID());
    return;
}
```
Se hai un sistema Mesh o più Access Point con lo **stesso identico SSID**, questo codice **non effettuerà mai il roaming** verso l'AP più forte. Per risolvere, dovresti confrontare l'indirizzo MAC (**BSSID**) invece del semplice nome SSID.

#### B. Errore di compilazione/logica in `update()`
Nel file `.cpp` leggo:
```cpp
m_lastScanTime = now; moved down // <--- Errore di sintassi
```
Oltre al testo "moved down" che rompe la compilazione, se resetti `m_lastScanTime` all'inizio del blocco `if (now - m_lastScanTime >= interval)`, ma poi lo sovrascrivi o lo gestisci male sotto, lo scan potrebbe attivarsi a intervalli irregolari.

#### C. Gestione dello stato "In connessione"
Il metodo `handleScanResult` chiama `WiFi.begin()`. Tuttavia, se `WiFi.begin()` è già stato chiamato e l'ESP32 sta cercando di connettersi, chiamarlo di nuovo interrompe il processo precedente.
*   **Rischio**: Se lo scan finisce mentre l'ESP32 sta ancora tentando di autenticarsi, potresti entrare in un loop di disconnessioni. Bisognerebbe controllare se `WiFi.status() == WL_IDLE_STATUS` o se c'è un flag `m_isConnecting`.

#### D. Reset del timeout
In `update()`:
```cpp
if (now - m_lastConnectedTime > m_maxWifiTimeout) {
    startScan();
    m_lastConnectedTime = now;
}
```
Se non c'è nessuna rete conosciuta nell'area, questo blocco continuerà a resettare il timer e a far partire scan a vuoto ogni `m_maxWifiTimeout` millisecondi, sovrapponendosi potenzialmente agli intervalli di scan standard.

---

### 3. Suggerimenti di Miglioramento

#### 1. Supporto BSSID (Roaming vero)
Per gestire AP multipli con lo stesso SSID, salva il BSSID della connessione attuale:
```cpp
// Nel .h
uint8_t m_currentBSSID[6];

// Nel .cpp handleScanResult
uint8_t* bestBSSID = WiFi.BSSID(i);
// ... confronto tra bestBSSID e m_currentBSSID ...
```

#### 2. Logica di Scan più robusta
In `update()`, è meglio gestire lo stato dello scan in modo più granulare:
1.  Se non connesso e non in scansione -> `startScan()`.
2.  Se connesso e l'intervallo è passato -> `startScan()`.
3.  Quando `scanComplete >= 0` -> elabora i risultati.

#### 3. Ottimizzazione `platformio.ini`
Hai incluso `fbiego/ESP32Time @ ^2.0.6`, ma non sembra usata nel manager. Se non serve per il timestamp dei log, puoi rimuoverla per risparmiare spazio.
Inoltre, il flag `-I /home/loreto/...` rende il progetto **non portabile**. Se qualcun altro scarica il codice, non compilerà. Usa cartelle relative al progetto (es. `include/`).

#### 4. Pulizia automatica `WiFi.scanDelete()`
Chiamare `WiFi.scanDelete()` è corretto per liberare memoria RAM dopo ogni scansione, ma assicurati che venga chiamato *sempre* dopo `handleScanResult()`.

---

### 4. Esempio di fix per il Roaming (Logica suggerita)

Sostituisci la parte di confronto in `handleScanResult` con questa logica:

```cpp
if (WiFi.status() == WL_CONNECTED) {
    int currentRSSI = WiFi.RSSI();
    // Se la rete migliore è quella a cui sono già connesso (stesso SSID)
    if (bestSSID == WiFi.SSID()) {
        // Se il guadagno non è sufficiente, non fare nulla
        if ((bestRSSI - currentRSSI) < m_rssiGap) {
            return; 
        }
        // Se arrivo qui, ho trovato un AP con lo STESSO SSID ma segnale molto più forte
        Serial.println("Switching to stronger AP with same SSID");
    } else {
        // Se è un SSID diverso, procedo comunque con il controllo del gap
        if ((bestRSSI - currentRSSI) < m_rssiGap) {
            return;
        }
    }
    WiFi.disconnect();
}
```

### Conclusione
Il codice è ben scritto e segue le best-practices per ESP32 (uso di `vector`, eventi, asincronia). Una volta sistemato il piccolo errore di sintassi in `update()` e raffinata la logica di confronto degli SSID (per gestire mesh/ripetitori), sarà un componente molto solido.

**Voto attuale: 7.5/10** (Diventa 9/10 con la gestione del roaming BSSID e la pulizia dei timer).
