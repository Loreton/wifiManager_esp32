--- CONTESTO PROGETTO ESP32 ---


--- FILE: ./platformio.ini ---
;PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html

; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html



; [env:esp32_littleFS]
[env:esp32]
    # # sembra funzionare con AzDelivery ESP32-WROOM 32
    ; platform = espressif32@^6.8.0   #; 6.0.0. or the latest stable version (per ledcSetup())
    platform = espressif32
    framework = arduino
    board = esp32dev
    upload_speed = 460800
    monitor_speed = 115200
    monitor_filters = colorize
    upload_port = /dev/ttyUSB0
    # board_build.filesystem = littlefs
    # extra_scripts = presscontrol_extra_flags.py



    # -------------------------------------
    # ref: https://docs.platformio.org/en/stable/search.html?q=lib_deps&check_keywords=yes&area=default
    #   per le mie librerie posso ettere il path di github:
    #       https://github.com/Loreton/wifiManager.git
    # -------------------------------------
    lib_deps =
        ; paulstoffregen/OneWire @ ^2.3.8
        ; milesburton/DallasTemperature @ ^4.0.6
        ; Aircoookie/Espalexa @ ^2.7.0
        ; witnessmenow/UniversalTelegramBot @ ^1.3.0
        fbiego/ESP32Time @ ^2.0.6
        ; https://github.com/Loreton/wifiManager.git
        ; cotestatnt/AsyncTelegram2 @ ^2.1.8


    # -------------------------------------
    # ref: https://docs.platformio.org/en/stable/projectconf/sections/env/options/build/build_flags.html
    # -------------------------------------
    build_flags=
        # -D LOG_LEVEL=${sysenv.LOG_LEVEL}
        ${sysenv.ADDITIONAL_BUILD_FLAGS}
        ; -I ./include
        -I /home/loreto/filu/lnEnv/config/envars/include # per ssid.h e telegram_bot.h  @ln_ssid_credentials.h
        ; -D __ln_MODULE_DEBUG_TEST__



    ; ref: https://docs.platformio.org/en/stable/projectconf/sections/env/options/library/lib_ignore.html
    lib_ignore =
        @testArea # solo nome del folder senza il path
        examples # solo nome del folder senza il path
        samples # solo nome del folder senza il path


    # -------------------------------------
    # inserire le librerie esterne o personali da includere nella compilazione
    # considerare che pr i relative path, la base_dir --> same level of src
    # -------------------------------------
    lib_extra_dirs =
        ; ../lnEsp32Libraries


    # -------------------------------------
    # ref: https://docs.platformio.org/en/stable/projectconf/sections/env/options/build/build_src_filter.html
    # inserire tutti i percorsi che si desidera inserire nel codice
    # considerare che per i relative path, la base_dir --> src
    # -------------------------------------
    build_src_filter =
        ; +<./test>







[platformio]
    ; src_dir = .
    # ref: https://docs.platformio.org/en/latest/projectconf/sections/platformio/options/directory/lib_dir.html
    # default_envs = nodemcu32
    default_envs = esp32
    # default_envs = esp32




--- FILE: ./src/WiFiManager.h ---
//
// updated by ...: Loreto Notarantonio
// Date .........: 13-09-2025 17.32.34
//


#pragma once

#include <Arduino.h>
#include <WiFi.h>
#include <vector>

class WiFiManagerNB {
    public:
        WiFiManagerNB();

        void init(uint32_t scanIntervalWhenConnected,
                  uint32_t scanIntervalWhenNotConnected,
                  uint32_t maxWifiTimeout,
                  int rssiGap);

        void update();
        void addSSID(const char* ssid, const char* password);

        bool isConnected();
        String getConnectedSSID();

    private:
        static WiFiManagerNB* s_instance;
        static void WiFiEventHandler(WiFiEvent_t event, WiFiEventInfo_t info);

        struct WifiCredential {
            String ssid;
            String password;
        };

        std::vector<WifiCredential> m_credentials;

        uint32_t m_scanIntervalWhenConnected;
        uint32_t m_scanIntervalWhenNotConnected;
        uint32_t m_maxWifiTimeout;

        uint32_t m_lastScanTime = 0;
        uint32_t m_lastConnectedTime = 0;

        int m_rssiGap;
        String m_currentSSID;

        void startScan();
        void handleScanResult();
        void connectToBestNetwork();
        void onWiFiEvent(WiFiEvent_t event);
};



--- FILE: ./src/WiFiManager.cpp ---
//
// updated by ...: Loreto Notarantonio
// Date .........: 20-02-2026 17.16.03
//


// #include "lnLogger_Class.h"

#include "WiFiManager.h"

WiFiManagerNB::WiFiManagerNB() {}
WiFiManagerNB* WiFiManagerNB::s_instance = nullptr;

void WiFiManagerNB::init(uint32_t scanIntervalWhenConnected, uint32_t scanIntervalWhenNotConnected, uint32_t maxWifiTimeout, int rssiGap) {
    m_scanIntervalWhenConnected = scanIntervalWhenConnected;
    m_scanIntervalWhenNotConnected = scanIntervalWhenNotConnected;
    m_maxWifiTimeout = maxWifiTimeout;
    m_rssiGap = rssiGap;

    WiFi.mode(WIFI_STA);
    WiFi.disconnect(true);

    s_instance = this;
    WiFi.onEvent(WiFiEventHandler);

    startScan();
}


void WiFiManagerNB::WiFiEventHandler(WiFiEvent_t event, WiFiEventInfo_t info) {
    if (s_instance) {
        s_instance->onWiFiEvent(event);
    }
}





// =======================================================
//  wifiManager.addSSID("Casetta", "PASSWORD1");
//  wifiManager.addSSID("SSID2", "PASSWORD2");
//  wifiManager.addSSID("SSID3", "PASSWORD3");
// =======================================================
void WiFiManagerNB::addSSID(const char* ssid, const char* password) {
    Serial.println(ssid);
    WifiCredential cred;
    cred.ssid = ssid;
    cred.password = password;
    m_credentials.push_back(cred);
}

void WiFiManagerNB::update() {
    uint32_t now = millis();

    bool connected = (WiFi.status() == WL_CONNECTED);

    if (connected) {
        m_lastConnectedTime = now;
    }
    else {
        if (now - m_lastConnectedTime > m_maxWifiTimeout) {
            Serial.println("Max WiFi timeout reached. Restarting scan.");
            startScan();
            m_lastConnectedTime = now;
        }
    }

    uint32_t interval = connected ? m_scanIntervalWhenConnected : m_scanIntervalWhenNotConnected;
    if (now - m_lastScanTime >= interval) {
        m_lastScanTime = now; moved down
        startScan();
    }

    int scanStatus = WiFi.scanComplete();
    if (scanStatus >= 0) {
        handleScanResult();
        WiFi.scanDelete();
        // m_lastScanTime = now; // spostato come suggerito
    }
}

void WiFiManagerNB::startScan() {
    if (WiFi.scanComplete() == -2) {// no scan running
        Serial.println("Starting scan....");
        WiFi.scanNetworks(true); // async
    }
}

void WiFiManagerNB::handleScanResult() {
    int n = WiFi.scanComplete();
    if (n <= 0)
        return;

    int bestRSSI = -1000;
    String bestSSID = "";
    String bestPassword = "";

    for (int i = 0; i < n; ++i) {
        String ssid = WiFi.SSID(i);
        int rssi = WiFi.RSSI(i);
        Serial.print("SSID: ");Serial.print(ssid);Serial.print(" - RSSI: ");Serial.println(rssi);

        for (auto &cred : m_credentials) {
            if (ssid == cred.ssid) {
                if (rssi > bestRSSI) {
                    bestRSSI = rssi;
                    bestSSID = cred.ssid;
                    bestPassword = cred.password;
                }
            }
        }
    }

    if (bestSSID == "") {
        Serial.print("no better SSID found. standing on: ");Serial.println(WiFi.SSID());
        return;
    }

    if (WiFi.status() == WL_CONNECTED) {
        int currentRSSI = WiFi.RSSI();
        // Se la rete migliore è quella a cui sono già connesso (stesso SSID)
        if (bestSSID == WiFi.SSID()) {
            // Se il guadagno non è sufficiente, non fare nulla
            if ((bestRSSI - currentRSSI) < m_rssiGap) {
                return;
            }
            // Se arrivo qui, ho trovato un AP con lo STESSO SSID ma segnale molto più forte
            Serial.println("Switching to stronger AP with same SSID");
        } else {
            // Se è un SSID diverso, procedo comunque con il controllo del gap
            if ((bestRSSI - currentRSSI) < m_rssiGap) {
                return;
            }
        }
        WiFi.disconnect();
    }


/*    if (WiFi.status() == WL_CONNECTED) {
        int currentRSSI = WiFi.RSSI();
        if (bestSSID == m_currentSSID) {
            Serial.print("best ssid is already active: ");Serial.println(WiFi.SSID());
            return;
        }

        if ((bestRSSI - currentRSSI) < m_rssiGap) {
            Serial.print("gap between current ssid and best ssid is:");Serial.println(bestRSSI - currentRSSI);
            return;
        }

        Serial.println("Switching to stronger SSID: " + bestSSID);
        WiFi.disconnect();
    }
*/
    m_currentSSID = bestSSID;
    WiFi.begin(bestSSID.c_str(), bestPassword.c_str());
}

void WiFiManagerNB::onWiFiEvent(WiFiEvent_t event) {
    switch (event) {
        case ARDUINO_EVENT_WIFI_STA_CONNECTED:
            Serial.println("WiFi Connected");
            break;

        case ARDUINO_EVENT_WIFI_STA_GOT_IP:
            Serial.println("Got IP: " + WiFi.localIP().toString());
            break;

        case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:
            Serial.println("WiFi Disconnected");
            break;

        default:
            break;
    }
}

bool WiFiManagerNB::isConnected() {
    return WiFi.status() == WL_CONNECTED;
}

String WiFiManagerNB::getConnectedSSID() {
    return m_currentSSID;
}


USER QUESTION: Analizza il codice